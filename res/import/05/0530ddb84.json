[{"__type__":"cc.Mesh","_native":".bin","_struct":{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"geometricInfo":{"view":{"offset":1152,"length":288,"count":72,"stride":4}},"indexView":{"offset":1440,"length":72,"count":36,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":43,"isNormalized":false}]}],"minPosition":{"__type__":"cc.Vec3","x":-0.5,"y":-0.5,"z":-0.5},"maxPosition":{"__type__":"cc.Vec3","x":0.5,"y":0.5,"z":0.5}},"_dataLength":1512,"_hash":576558724},{"__type__":"cc.EffectAsset","_name":"builtin-standard","techniques":[{"name":"opaque","passes":[{"program":"builtin-standard|standard-vs:vert|standard-fs:frag","properties":{"tilingOffset":{"value":[1,1,0,0],"type":16},"mainColor":{"value":[1,1,1,1],"type":16,"handleInfo":["albedo",0,16]},"albedoScale":{"value":[1,1,1],"type":15,"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"value":[0.5],"type":13,"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"value":[1],"type":13,"handleInfo":["pbrParams",0,13]},"roughness":{"value":[0.8],"type":13,"handleInfo":["pbrParams",1,13]},"metallic":{"value":[0.6],"type":13,"handleInfo":["pbrParams",2,13]},"normalStrenth":{"value":[1],"type":13,"handleInfo":["pbrParams",3,13]},"emissive":{"value":[0,0,0,1],"type":16},"emissiveScale":{"value":[1,1,1],"type":15,"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"value":[1,1,1,0.5]},"pbrParams":{"type":16,"value":[1,0.8,0.6,1]},"emissiveScaleParam":{"type":16,"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey"}}}]},{"name":"transparent","passes":[{"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"program":"builtin-standard|standard-vs:vert|standard-fs:frag","depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"value":[1,1,0,0],"type":16},"mainColor":{"value":[1,1,1,1],"type":16,"handleInfo":["albedo",0,16]},"albedoScale":{"value":[1,1,1],"type":15,"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"value":[0.5],"type":13,"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"value":[1],"type":13,"handleInfo":["pbrParams",0,13]},"roughness":{"value":[0.8],"type":13,"handleInfo":["pbrParams",1,13]},"metallic":{"value":[0.6],"type":13,"handleInfo":["pbrParams",2,13]},"normalStrenth":{"value":[1],"type":13,"handleInfo":["pbrParams",3,13]},"emissive":{"value":[0,0,0,1],"type":16},"emissiveScale":{"value":[1,1,1],"type":15,"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"value":[1,1,1,0.5]},"pbrParams":{"type":16,"value":[1,0.8,0.6,1]},"emissiveScaleParam":{"type":16,"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey"}}}]}],"shaders":[{"hash":3845416769,"glsl3":{"vert":"\nprecision highp float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\n#if USE_BATCHING\n  in float a_dyn_batch_id;\n  uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n};\n#endif\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec4 a_tangent;\n#if USE_SKINNING\nin vec4 a_weights;\nin vec4 a_joints;\nuniform CCSkinningTexture {\n  highp vec4 cc_jointsTextureInfo;\n};\nuniform CCSkinningAnimation {\n  highp vec4 cc_jointsAnimInfo;\n};\nuniform sampler2D cc_jointsTexture;\n#if USE_SKINNING == 1\n  highp float decode32 (highp vec4 rgba) {\n    rgba = rgba * 255.0;\n    highp float Sign = 1.0 - step(128.0, rgba[3]) * 2.0;\n    highp float Exponent = 2.0 * mod(rgba[3], 128.0) + step(128.0, rgba[2]) - 127.0;\n    highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n  }\n#endif\n#if USE_SKINNING == 1\n  mat4 getJointMatrix (float i) {\n    highp float j = 12.0 * (cc_jointsAnimInfo.x * i + cc_jointsAnimInfo.y) + cc_jointsTextureInfo.z;\n    highp float invSize = cc_jointsTextureInfo.y;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    vec4 v1 = vec4(\n      decode32(texture(cc_jointsTexture, vec2((x + 0.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 1.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 2.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 3.5) * invSize, y)))\n    );\n    vec4 v2 = vec4(\n      decode32(texture(cc_jointsTexture, vec2((x + 4.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 5.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 6.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 7.5) * invSize, y)))\n    );\n    vec4 v3 = vec4(\n      decode32(texture(cc_jointsTexture, vec2((x + 8.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 9.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 10.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 11.5) * invSize, y)))\n    );\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#elif USE_SKINNING == 2\n  mat4 getJointMatrix (float i) {\n    highp float j = 3.0 * (cc_jointsAnimInfo.x * i + cc_jointsAnimInfo.y) + cc_jointsTextureInfo.z;\n    highp float invSize = cc_jointsTextureInfo.y;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    vec4 v1 = texture(cc_jointsTexture, vec2((x + 0.5) * invSize, y));\n    vec4 v2 = texture(cc_jointsTexture, vec2((x + 1.5) * invSize, y));\n    vec4 v3 = texture(cc_jointsTexture, vec2((x + 2.5) * invSize, y));\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n    + getJointMatrix(a_joints.y) * a_weights.y;\n    + getJointMatrix(a_joints.z) * a_weights.z;\n    + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nuniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\n#if USE_VERTEX_COLOR\n  in vec3 a_color;\n  out vec3 v_color;\n#endif\nout vec3 v_position;\nout vec3 v_normal;\n#if USE_NORMAL_MAP\n  out vec3 v_tangent;\n  out vec3 v_bitangent;\n#endif\nin vec2 a_texCoord;\nout vec2 v_uv;\nin vec2 a_texCoord1;\nout vec2 v_uv1;\nvec4 vert () {\n  StandardVertInput In;\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n  In.tangent = a_tangent;\n  #if USE_SKINNING\n    CCSkin(In);\n  #endif\n  mat4 matWorld, matWorldIT;\n  #if USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id + 0.5)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorldIT * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  return cc_matProj * (cc_matView * matWorld) * In.position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\n#endif\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nuniform CCForwardLight {\n  highp vec4 cc_sphereLitPos[2];\n  vec4 cc_sphereLitSizeRange[2];\n  vec4 cc_sphereLitColor[2];\n  highp vec4 cc_spotLitPos[2];\n  vec4 cc_spotLitSizeRangeAngle[2];\n  vec4 cc_spotLitDir[2];\n  vec4 cc_spotLitColor[2];\n};\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness*0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\nvec3 CalcDynamicLighting (vec3 worldPos, vec3 N, vec3 V, vec3 diffuse, vec3 specular, float roughness) {\n  vec3 lighting = vec3(0.0);\n  vec3 diffuseContrib = diffuse / 3.14159265359;\n  for (int i = 0; i < 2; i++) {\n    vec3 PLU = cc_sphereLitPos[i].xyz - worldPos;\n    vec3 PL = normalize(PLU);\n    vec3 PH = normalize(PL + V);\n    float PNL = max(dot(N, PL), 0.001);\n    float PNH = max(dot(N, PH), 0.0);\n    float distSqr = dot(PLU, PLU);\n    float litRadius = cc_sphereLitSizeRange[i].x;\n    float litRadiusSqr = litRadius * litRadius;\n    float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n    float attRadiusSqrInv = 1.0 / max(cc_sphereLitSizeRange[i].y, 0.01);\n    attRadiusSqrInv *= attRadiusSqrInv;\n    float att = GetDistAtt(distSqr, attRadiusSqrInv);\n    vec3 lspec = specular * CalcSpecular(roughness, PNH, PH, N);\n    lighting += PNL * cc_sphereLitColor[i].rgb * cc_sphereLitColor[i].w * illum * att * (diffuseContrib + lspec);\n  }\n  for (int i = 0; i < 2; i++) {\n    vec3 SLU = cc_spotLitPos[i].xyz - worldPos;\n    vec3 SL = normalize(SLU);\n    vec3 SH = normalize(SL + V);\n    float SNL = max(dot(N, SL), 0.001);\n    float SNH = max(dot(N, SH), 0.0);\n    float distSqr = dot(SLU, SLU);\n    float litRadius = cc_spotLitSizeRangeAngle[i].x;\n    float litRadiusSqr = litRadius * litRadius;\n    float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n    float attRadiusSqrInv = 1.0 / max(cc_spotLitSizeRangeAngle[i].y, 0.01);\n    attRadiusSqrInv *= attRadiusSqrInv;\n    float cosInner = max(dot(-cc_spotLitDir[i].xyz, SL), 0.01);\n    float cosOuter = cc_spotLitSizeRangeAngle[i].z;\n    float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n    float litAngleOffset = -cosOuter * litAngleScale;\n    float att = GetDistAtt(distSqr, attRadiusSqrInv);\n    att *= GetAngleAtt(SL, -cc_spotLitDir[i].xyz, litAngleScale, litAngleOffset);\n    vec3 lspec = specular * CalcSpecular(roughness, SNH, SH, N);\n    lighting += SNL * cc_spotLitColor[i].rgb * cc_spotLitColor[i].w * illum * att * (diffuseContrib + lspec);\n  }\n  return lighting;\n}\nstruct StandardSurface {\n  vec4 albedo;\n  vec3 position;\n  vec3 normal;\n  vec3 emissive;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\nvec4 CCStandardShading (StandardSurface s) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - s.position);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L+V);\n  float NV = max(abs(dot(N, V)), 0.001);\n  float NL = max(dot(N, L), 0.001);\n  float NH = max(dot(N, H), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 diffuseContrib = diffuse / 3.14159265359;\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w * (diffuseContrib + specularContrib);\n  finalColor += CalcDynamicLighting(s.position, N, V, diffuse, specular, s.roughness);\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n  finalColor += (ambDiff.rgb * diffuse);\n  #if CC_USE_IBL\n    vec3 R = normalize(reflect(-V, N));\n    vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n    #if CC_USE_IBL == 2\n      vec3 env = unpackRGBE(envmap);\n    #else\n      vec3 env = SRGBToLinear(envmap.rgb) * cc_ambientSky.w;\n    #endif\n    finalColor += env * specular;\n  #endif\n  finalColor = finalColor * s.occlusion;\n  #if CC_USE_HDR\n    s.emissive *= cc_exposure.w;\n  #endif\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nuniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nin vec3 v_position;\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec3 v_normal;\n#if USE_VERTEX_COLOR\n  in vec3 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= v_color;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * pbrParams.w) * normalize(v_tangent) +\n      (nmmp.y * pbrParams.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.OCCLUSION_CHANNEL;\n    pbr.y *= res.ROUGHNESS_CHANNEL;\n    pbr.z *= res.METALLIC_CHANNEL;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, METALLIC_ROUGHNESS_UV);\n    pbr.z *= metallicRoughness.METALLIC_CHANNEL;\n    pbr.y *= metallicRoughness.ROUGHNESS_CHANNEL;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, OCCLUSION_UV).OCCLUSION_CHANNEL;\n  #endif\n  s.occlusion = clamp(pbr.x, 0.0, 0.96);\n  s.roughness = clamp(pbr.y, 0.04, 1.0);\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\nvec4 frag () {\n  StandardSurface s; surf(s);\n  vec4 color = CCStandardShading(s);\n  return CCFragOutput(color);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\n#if USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\nuniform highp mat4 cc_matWorldIT;\n#endif\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec4 a_tangent;\n#if USE_SKINNING\nattribute vec4 a_weights;\nattribute vec4 a_joints;\nuniform highp vec4 cc_jointsTextureInfo;\nuniform highp vec4 cc_jointsAnimInfo;\nuniform sampler2D cc_jointsTexture;\n#if USE_SKINNING == 1\n  highp float decode32 (highp vec4 rgba) {\n    rgba = rgba * 255.0;\n    highp float Sign = 1.0 - step(128.0, rgba[3]) * 2.0;\n    highp float Exponent = 2.0 * mod(rgba[3], 128.0) + step(128.0, rgba[2]) - 127.0;\n    highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n  }\n#endif\n#if USE_SKINNING == 1\n  mat4 getJointMatrix (float i) {\n    highp float j = 12.0 * (cc_jointsAnimInfo.x * i + cc_jointsAnimInfo.y) + cc_jointsTextureInfo.z;\n    highp float invSize = cc_jointsTextureInfo.y;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    vec4 v1 = vec4(\n      decode32(texture2D(cc_jointsTexture, vec2((x + 0.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 1.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 2.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 3.5) * invSize, y)))\n    );\n    vec4 v2 = vec4(\n      decode32(texture2D(cc_jointsTexture, vec2((x + 4.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 5.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 6.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 7.5) * invSize, y)))\n    );\n    vec4 v3 = vec4(\n      decode32(texture2D(cc_jointsTexture, vec2((x + 8.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 9.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 10.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 11.5) * invSize, y)))\n    );\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#elif USE_SKINNING == 2\n  mat4 getJointMatrix (float i) {\n    highp float j = 3.0 * (cc_jointsAnimInfo.x * i + cc_jointsAnimInfo.y) + cc_jointsTextureInfo.z;\n    highp float invSize = cc_jointsTextureInfo.y;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    vec4 v1 = texture2D(cc_jointsTexture, vec2((x + 0.5) * invSize, y));\n    vec4 v2 = texture2D(cc_jointsTexture, vec2((x + 1.5) * invSize, y));\n    vec4 v3 = texture2D(cc_jointsTexture, vec2((x + 2.5) * invSize, y));\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n    + getJointMatrix(a_joints.y) * a_weights.y;\n    + getJointMatrix(a_joints.z) * a_weights.z;\n    + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nuniform vec4 tilingOffset;\n#if USE_VERTEX_COLOR\n  attribute vec3 a_color;\n  varying vec3 v_color;\n#endif\nvarying vec3 v_position;\nvarying vec3 v_normal;\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\nattribute vec2 a_texCoord;\nvarying vec2 v_uv;\nattribute vec2 a_texCoord1;\nvarying vec2 v_uv1;\nvec4 vert () {\n  StandardVertInput In;\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n  In.tangent = a_tangent;\n  #if USE_SKINNING\n    CCSkin(In);\n  #endif\n  mat4 matWorld, matWorldIT;\n  #if USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id + 0.5)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorldIT * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  return cc_matProj * (cc_matView * matWorld) * In.position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\n  #ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n  #endif\nprecision highp float;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_exposure;\nuniform mediump vec4 cc_mainLitDir;\nuniform mediump vec4 cc_mainLitColor;\nuniform mediump vec4 cc_ambientSky;\nuniform mediump vec4 cc_ambientGround;\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return texture2DLodEXT(tex, coord, lod);\n    #else\n      return texture2D(tex, coord, lod);\n    #endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return textureCubeLodEXT(tex, coord, lod);\n    #else\n      return textureCube(tex, coord, lod);\n    #endif\n}\n#endif\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nuniform highp vec4 cc_sphereLitPos[2];\nuniform vec4 cc_sphereLitSizeRange[2];\nuniform vec4 cc_sphereLitColor[2];\nuniform highp vec4 cc_spotLitPos[2];\nuniform vec4 cc_spotLitSizeRangeAngle[2];\nuniform vec4 cc_spotLitDir[2];\nuniform vec4 cc_spotLitColor[2];\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness*0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\nvec3 CalcDynamicLighting (vec3 worldPos, vec3 N, vec3 V, vec3 diffuse, vec3 specular, float roughness) {\n  vec3 lighting = vec3(0.0);\n  vec3 diffuseContrib = diffuse / 3.14159265359;\n  for (int i = 0; i < 2; i++) {\n    vec3 PLU = cc_sphereLitPos[i].xyz - worldPos;\n    vec3 PL = normalize(PLU);\n    vec3 PH = normalize(PL + V);\n    float PNL = max(dot(N, PL), 0.001);\n    float PNH = max(dot(N, PH), 0.0);\n    float distSqr = dot(PLU, PLU);\n    float litRadius = cc_sphereLitSizeRange[i].x;\n    float litRadiusSqr = litRadius * litRadius;\n    float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n    float attRadiusSqrInv = 1.0 / max(cc_sphereLitSizeRange[i].y, 0.01);\n    attRadiusSqrInv *= attRadiusSqrInv;\n    float att = GetDistAtt(distSqr, attRadiusSqrInv);\n    vec3 lspec = specular * CalcSpecular(roughness, PNH, PH, N);\n    lighting += PNL * cc_sphereLitColor[i].rgb * cc_sphereLitColor[i].w * illum * att * (diffuseContrib + lspec);\n  }\n  for (int i = 0; i < 2; i++) {\n    vec3 SLU = cc_spotLitPos[i].xyz - worldPos;\n    vec3 SL = normalize(SLU);\n    vec3 SH = normalize(SL + V);\n    float SNL = max(dot(N, SL), 0.001);\n    float SNH = max(dot(N, SH), 0.0);\n    float distSqr = dot(SLU, SLU);\n    float litRadius = cc_spotLitSizeRangeAngle[i].x;\n    float litRadiusSqr = litRadius * litRadius;\n    float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n    float attRadiusSqrInv = 1.0 / max(cc_spotLitSizeRangeAngle[i].y, 0.01);\n    attRadiusSqrInv *= attRadiusSqrInv;\n    float cosInner = max(dot(-cc_spotLitDir[i].xyz, SL), 0.01);\n    float cosOuter = cc_spotLitSizeRangeAngle[i].z;\n    float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n    float litAngleOffset = -cosOuter * litAngleScale;\n    float att = GetDistAtt(distSqr, attRadiusSqrInv);\n    att *= GetAngleAtt(SL, -cc_spotLitDir[i].xyz, litAngleScale, litAngleOffset);\n    vec3 lspec = specular * CalcSpecular(roughness, SNH, SH, N);\n    lighting += SNL * cc_spotLitColor[i].rgb * cc_spotLitColor[i].w * illum * att * (diffuseContrib + lspec);\n  }\n  return lighting;\n}\nstruct StandardSurface {\n  vec4 albedo;\n  vec3 position;\n  vec3 normal;\n  vec3 emissive;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\nvec4 CCStandardShading (StandardSurface s) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - s.position);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L+V);\n  float NV = max(abs(dot(N, V)), 0.001);\n  float NL = max(dot(N, L), 0.001);\n  float NH = max(dot(N, H), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 diffuseContrib = diffuse / 3.14159265359;\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w * (diffuseContrib + specularContrib);\n  finalColor += CalcDynamicLighting(s.position, N, V, diffuse, specular, s.roughness);\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n  finalColor += (ambDiff.rgb * diffuse);\n  #if CC_USE_IBL\n    vec3 R = normalize(reflect(-V, N));\n    vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n    #if CC_USE_IBL == 2\n      vec3 env = unpackRGBE(envmap);\n    #else\n      vec3 env = SRGBToLinear(envmap.rgb) * cc_ambientSky.w;\n    #endif\n    finalColor += env * specular;\n  #endif\n  finalColor = finalColor * s.occlusion;\n  #if CC_USE_HDR\n    s.emissive *= cc_exposure.w;\n  #endif\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nuniform vec4 albedo;\nuniform vec4 albedoScaleAndCutoff;\nuniform vec4 pbrParams;\nuniform vec4 emissive;\nuniform vec4 emissiveScaleParam;\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec3 v_normal;\n#if USE_VERTEX_COLOR\n  varying vec3 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= v_color;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * pbrParams.w) * normalize(v_tangent) +\n      (nmmp.y * pbrParams.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture2D(pbrMap, PBR_UV);\n    pbr.x *= res.OCCLUSION_CHANNEL;\n    pbr.y *= res.ROUGHNESS_CHANNEL;\n    pbr.z *= res.METALLIC_CHANNEL;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture2D(metallicRoughnessMap, METALLIC_ROUGHNESS_UV);\n    pbr.z *= metallicRoughness.METALLIC_CHANNEL;\n    pbr.y *= metallicRoughness.ROUGHNESS_CHANNEL;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture2D(occlusionMap, OCCLUSION_UV).OCCLUSION_CHANNEL;\n  #endif\n  s.occlusion = clamp(pbr.x, 0.0, 0.96);\n  s.roughness = clamp(pbr.y, 0.04, 1.0);\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\nvec4 frag () {\n  StandardSurface s; surf(s);\n  vec4 color = CCStandardShading(s);\n  return CCFragOutput(color);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]}],"samplers":[{"name":"cc_environment","defines":["CC_USE_IBL"]}]},"locals":{"blocks":[{"name":"CCLocalBatched","defines":["USE_BATCHING"]},{"name":"CCLocal","defines":[]},{"name":"CCSkinningTexture","defines":["USE_SKINNING"]},{"name":"CCSkinningAnimation","defines":["USE_SKINNING"]},{"name":"CCForwardLight","defines":[]}],"samplers":[{"name":"cc_jointsTexture","defines":["USE_SKINNING"]}]}},"defines":[{"name":"USE_BATCHING","type":"boolean"},{"name":"USE_SKINNING","type":"boolean"},{"name":"USE_VERTEX_COLOR","type":"boolean"},{"name":"USE_NORMAL_MAP","type":"boolean"},{"name":"HAS_SECOND_UV","type":"boolean"},{"name":"CC_USE_IBL","type":"number","range":[0,2]},{"name":"CC_USE_HDR","type":"boolean"},{"name":"USE_ALBEDO_MAP","type":"boolean"},{"name":"ALBEDO_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"NORMAL_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_PBR_MAP","type":"boolean"},{"name":"PBR_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_METALLIC_ROUGHNESS_MAP","type":"boolean"},{"name":"METALLIC_ROUGHNESS_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_OCCLUSION_MAP","type":"boolean"},{"name":"OCCLUSION_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_EMISSIVE_MAP","type":"boolean"},{"name":"EMISSIVE_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"OCCLUSION_CHANNEL","type":"string","options":["r","g","b"]},{"name":"ROUGHNESS_CHANNEL","type":"string","options":["g","b","r"]},{"name":"METALLIC_CHANNEL","type":"string","options":["b","r","g"]},{"name":"USE_ALPHA_TEST","type":"boolean"},{"name":"ALPHA_TEST_CHANNEL","type":"string","options":["a","r"]}],"blocks":[{"name":"Constants","members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[],"binding":0}],"samplers":[{"name":"albedoMap","type":28,"count":1,"defines":["USE_ALBEDO_MAP"],"binding":30},{"name":"normalMap","type":28,"count":1,"defines":["USE_NORMAL_MAP"],"binding":31},{"name":"pbrMap","type":28,"count":1,"defines":["USE_PBR_MAP"],"binding":32},{"name":"metallicRoughnessMap","type":28,"count":1,"defines":["USE_METALLIC_ROUGHNESS_MAP"],"binding":33},{"name":"occlusionMap","type":28,"count":1,"defines":["USE_OCCLUSION_MAP"],"binding":34},{"name":"emissiveMap","type":28,"count":1,"defines":["USE_EMISSIVE_MAP"],"binding":35}],"record":null,"name":"builtin-standard|standard-vs:vert|standard-fs:frag"}]},{"__type__":"cc.Material","_effectAsset":{"__uuid__":"1brw/JvvpFnIvdrxpFCgMZ"},"_defines":[{"USE_ALBEDO_MAP":true}],"_states":[{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}}],"_props":[{"mainColor":{"__type__":"cc.Color","r":255,"g":116,"b":253},"mainTexture":{"__uuid__":"a1ih0MqzRL/7RNLTanAapD@6c48a"}}]},{"__type__":"cc.Material","_effectAsset":{"__uuid__":"1brw/JvvpFnIvdrxpFCgMZ"},"_defines":[{"USE_ALBEDO_MAP":true}],"_states":[{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}}],"_props":[{"mainColor":{"__type__":"cc.Color","r":255,"g":231,"b":53},"mainTexture":{"__uuid__":"a1ih0MqzRL/7RNLTanAapD@6c48a"}}]},{"__type__":"cc.Material","_effectAsset":{"__uuid__":"1brw/JvvpFnIvdrxpFCgMZ"},"_defines":[{"USE_ALBEDO_MAP":true}],"_states":[{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}}],"_props":[{"mainColor":{"__type__":"cc.Color","r":255,"g":143},"mainTexture":{"__uuid__":"a1ih0MqzRL/7RNLTanAapD@6c48a"}}]},{"__type__":"cc.Material","_effectAsset":{"__uuid__":"1brw/JvvpFnIvdrxpFCgMZ"},"_defines":[{"USE_ALBEDO_MAP":true}],"_states":[{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}}],"_props":[{"mainColor":{"__type__":"cc.Color","r":87,"g":255,"b":107},"mainTexture":{"__uuid__":"a1ih0MqzRL/7RNLTanAapD@6c48a"}}]},{"__type__":"cc.Material","_effectAsset":{"__uuid__":"1brw/JvvpFnIvdrxpFCgMZ"},"_defines":[{}],"_states":[{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}}],"_props":[{"mainColor":{"__type__":"cc.Color","r":156,"g":156,"b":156}}]},{"__type__":"cc.Material","_effectAsset":{"__uuid__":"1brw/JvvpFnIvdrxpFCgMZ"},"_defines":[{"USE_ALBEDO_MAP":true}],"_states":[{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}}],"_props":[{"mainColor":{"__type__":"cc.Color","r":255,"b":163},"mainTexture":{"__uuid__":"a1ih0MqzRL/7RNLTanAapD@6c48a"}}]},{"__type__":"cc.Material","_effectAsset":{"__uuid__":"1brw/JvvpFnIvdrxpFCgMZ"},"_defines":[{}],"_states":[{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}}],"_props":[{"mainColor":{"__type__":"cc.Color","r":254,"g":223,"b":255}}]},[{"__type__":"cc.SceneAsset","scene":{"__id__":1}},{"__type__":"cc.Scene","_children":[{"__id__":2},{"__id__":3},{"__id__":13},{"__id__":10},{"__id__":24},{"__id__":27}],"_globals":{"__type__":"cc.SceneGlobals","ambient":{"__type__":"cc.AmbientInfo","_skyColor":{"__type__":"cc.Color","r":255,"g":255,"b":255},"_skyIllum":65000,"_groundAlbedo":{"__type__":"cc.Color"}},"planarShadows":{"__type__":"cc.PlanarShadowInfo"},"_skybox":{"__type__":"cc.SkyboxInfo"}}},{"__type__":"cc.Node","_name":"Main Light","_parent":{"__id__":1},"_components":[{"__type__":"cc.DirectionalLightComponent","node":{"__id__":2}}],"_lrot":{"__type__":"cc.Quat","x":-0.25,"y":-0.25,"z":-0.067,"w":0.933},"_id":"c0y6F5f+pAvI805TdmxIjx"},{"__type__":"cc.Node","_name":"Canvas","_parent":{"__id__":1},"_children":[{"__id__":4},{"__id__":7},{"__id__":29},{"__id__":28},{"__id__":22}],"_components":[{"__type__":"cc.UITransformComponent","node":{"__id__":3},"_contentSize":{"__type__":"cc.Size","width":640,"height":960}},{"__type__":"cc.CanvasComponent","node":{"__id__":3}}],"_lpos":{"__type__":"cc.Vec3","x":320,"y":480,"z":1},"_layer":33554432,"_id":"28MJVrL6VKiqkfDYB7qh0F"},{"__type__":"cc.Node","_name":"alert","_parent":{"__id__":3},"_components":[{"__type__":"cc.UITransformComponent","node":{"__id__":4},"_contentSize":{"__type__":"cc.Size","width":640,"height":960}},{"__type__":"cc.SpriteComponent","node":{"__id__":4},"_color":{"__type__":"cc.Color","r":179,"g":179,"b":179,"a":128},"_spriteFrame":{"__uuid__":"7dj5uJT9FMn6OrOOx83tfK@f9941"},"_type":1,"_sizeMode":0},{"__id__":5},{"__type__":"cc.WidgetComponent","node":{"__id__":4},"_alignFlags":45,"_originalWidth":450,"_originalHeight":340}],"_layer":33554432},{"__type__":"e2a49EplghPT6+/WnG7VV+J","node":{"__id__":4},"lable":{"__id__":6},"pm":{"__id__":9},"RETRY":{"__id__":28}},{"__type__":"cc.LabelComponent","node":{"__id__":7},"_color":{"__type__":"cc.Color"},"_string":"你赢了！","_verticalAlign":0,"_actualFontSize":60,"_fontSize":60,"_lineHeight":60,"_overflow":2,"_enableWrapText":false,"_font":{"__uuid__":"61db6zNg9MjLsrLAkPDs8R"},"_isSystemFontUsed":false},{"__type__":"cc.Node","_name":"Label","_parent":{"__id__":3},"_children":[{"__id__":8}],"_components":[{"__type__":"cc.UITransformComponent","node":{"__id__":7},"_contentSize":{"__type__":"cc.Size","width":500,"height":500},"_anchorPoint":{"__type__":"cc.Vec2","x":0.5,"y":1}},{"__id__":6}],"_lpos":{"__type__":"cc.Vec3","y":200},"_layer":33554432},{"__type__":"cc.Node","_name":"TATC","_parent":{"__id__":7},"_components":[{"__type__":"cc.UITransformComponent","node":{"__id__":8},"_contentSize":{"__type__":"cc.Size","width":531.18,"height":60}},{"__type__":"cc.LabelComponent","node":{"__id__":8},"_color":{"__type__":"cc.Color"},"_string":"点击任意的方继续…","_actualFontSize":60,"_fontSize":60,"_lineHeight":60,"_font":{"__uuid__":"61db6zNg9MjLsrLAkPDs8R"},"_isSystemFontUsed":false}],"_lpos":{"__type__":"cc.Vec3","y":-300},"_layer":33554432},{"__type__":"311cb3SOVJKB4g4X7JCXaRb","node":{"__id__":10},"floorCreator":{"__id__":11},"gamingManager":{"__id__":23}},{"__type__":"cc.Node","_name":"principalManager","_parent":{"__id__":1},"_components":[{"__id__":9}],"_id":"f4TwDk0ShDnqPqP2qRcW16"},{"__type__":"a6876dF07RJi4gSS/0fISjg","node":{"__id__":12},"pfNothing":{"__id__":20},"pfObstacle":{"__id__":17},"pfBlock":{"__id__":15},"level":{"__id__":21},"mtls":[{"__uuid__":"88dl67XKxPvpcrynMw3Nq+"},{"__uuid__":"33Re1uZXZFAbonj5FWMh97"},{"__uuid__":"b9PbfsCgNLwrus8cJ72pKt"},{"__uuid__":"1fDbqUZzBCdptP/+mE+qcw"},{"__uuid__":"47Te4kR2RMWpJ5z5LxjSjp"},{"__uuid__":"34+/YordNHE7YNASXpnQ/S"}],"spts":[{"__uuid__":"a1ih0MqzRL/7RNLTanAapD@6c48a"},{"__uuid__":"54mLNtNIVFVr4Z4WTGTF0S@6c48a"},{"__uuid__":"f0iD6upjhALZeAf2j0CY70@6c48a"},{"__uuid__":"5cmzqWHQdIsKmkMSBmRxQJ@6c48a"},{"__uuid__":"b6p0gW/wNImYwtDJ/zi+Xv@6c48a"},{"__uuid__":"037Q0WMJtMf7SacunMC+vA@6c48a"}]},{"__type__":"cc.Node","_name":"floorCreator","_parent":{"__id__":13},"_components":[{"__id__":11}]},{"__type__":"cc.Node","_name":"floor","_parent":{"__id__":1},"_children":[{"__id__":14},{"__id__":12}],"_id":"98Yb31sJ9Lt5VHhwB0pL2C"},{"__type__":"cc.Node","_name":"floor-bottom","_parent":{"__id__":13},"_children":[{"__id__":15},{"__id__":17},{"__id__":20}],"_components":[{"__type__":"cc.ModelComponent","_name":"Cube<ModelComponent>","node":{"__id__":14},"_materials":[{"__uuid__":"abNqwopyhH/7/z1YS8Q7az"}],"_mesh":{"__uuid__":"12Y9dMgWdJKJGmTiZyQR9H@a804a"}}],"_lpos":{"__type__":"cc.Vec3","y":-0.5},"_lscale":{"__type__":"cc.Vec3","x":25,"y":1,"z":30}},{"__type__":"cc.Node","_name":"blocks","_parent":{"__id__":14},"_children":[{"__id__":16}]},{"__type__":"cc.Node","_name":"Cube","_parent":{"__id__":15},"_components":[{"__type__":"cc.ModelComponent","_name":"Cube<ModelComponent>","node":{"__id__":16},"_mesh":{"__uuid__":"12Y9dMgWdJKJGmTiZyQR9H@a804a"}}],"_lscale":{"__type__":"cc.Vec3","x":1,"y":0.333333,"z":1}},{"__type__":"cc.Node","_name":"floor-top","_parent":{"__id__":14},"_children":[{"__id__":18}]},{"__type__":"cc.Node","_name":"root","_parent":{"__id__":17},"_children":[{"__id__":19}]},{"__type__":"cc.Node","_name":"bottom","_parent":{"__id__":18},"_components":[{"__type__":"cc.ModelComponent","_name":"Plane<ModelComponent>","node":{"__id__":19},"_materials":[{"__uuid__":"7128eAaz1Odrv6H0fRrifN"}],"_mesh":{"__uuid__":"12Y9dMgWdJKJGmTiZyQR9H@a804a"}}],"_lscale":{"__type__":"cc.Vec3","x":1,"y":0.333333,"z":1}},{"__type__":"cc.Node","_name":"floor-top-nothing","_parent":{"__id__":14}},{"__type__":"cc.LabelComponent","node":{"__id__":22},"_color":{"__type__":"cc.Color"},"_string":"第1关","_actualFontSize":75,"_fontSize":75,"_lineHeight":75,"_overflow":2,"_enableWrapText":false,"_font":{"__uuid__":"61db6zNg9MjLsrLAkPDs8R"},"_isSystemFontUsed":false},{"__type__":"cc.Node","_name":"level","_parent":{"__id__":3},"_components":[{"__type__":"cc.UITransformComponent","node":{"__id__":22},"_contentSize":{"__type__":"cc.Size","width":350,"height":75}},{"__id__":21},{"__type__":"cc.WidgetComponent","node":{"__id__":22},"_alignFlags":41,"_left":145,"_right":145,"_top":42.5,"_originalWidth":350}],"_lpos":{"__type__":"cc.Vec3","y":400},"_layer":33554432},{"__type__":"e29978G82pFBpxB5U/maz/Y","node":{"__id__":24},"floorCreator":{"__id__":11},"ccomp":{"__id__":25},"alert":{"__id__":5},"btnReset":{"__id__":28},"pm":{"__id__":9}},{"__type__":"cc.Node","_name":"gamingManager","_parent":{"__id__":1},"_components":[{"__id__":23}],"_id":"033HHwC0JD0YOmgvJvVoEa"},{"__type__":"cc.CameraComponent","node":{"__id__":26},"_color":{"__type__":"cc.Color","g":255,"b":255},"_visibility":1822425087},{"__type__":"cc.Node","_name":"Camera","_parent":{"__id__":27},"_components":[{"__id__":25}],"_lpos":{"__type__":"cc.Vec3","x":2,"y":-5,"z":25},"_lrot":{"__type__":"cc.Quat","x":0.0984591288890843,"y":0.03971019100159339,"z":-0.003932083631778315,"w":0.9943407058887473},"_euler":{"__type__":"cc.Vec3","x":11.309932,"y":4.573921}},{"__type__":"cc.Node","_name":"camera","_parent":{"__id__":1},"_children":[{"__id__":26}],"_lrot":{"__type__":"cc.Quat","x":-0.7071067811865475,"w":0.7071067811865476},"_euler":{"__type__":"cc.Vec3","x":-90},"_id":"7cS2V9CP1Nf5m5eoo4856x"},{"__type__":"cc.Node","_name":"again","_parent":{"__id__":3},"_components":[{"__type__":"cc.UITransformComponent","node":{"__id__":28},"_contentSize":{"__type__":"cc.Size","width":120,"height":40}},{"__type__":"cc.WidgetComponent","node":{"__id__":28},"_alignFlags":33,"_right":30.000000000000057,"_top":60},{"__type__":"cc.LabelComponent","node":{"__id__":28},"_color":{"__type__":"cc.Color"},"_string":"重新来","_actualFontSize":40,"_font":{"__uuid__":"61db6zNg9MjLsrLAkPDs8R"},"_isSystemFontUsed":false}],"_lpos":{"__type__":"cc.Vec3","x":229.99999999999994,"y":400}},{"__type__":"cc.Node","_name":"back","_parent":{"__id__":3},"_components":[{"__type__":"cc.UITransformComponent","node":{"__id__":29},"_contentSize":{"__type__":"cc.Size","width":80,"height":40}},{"__type__":"cc.ButtonComponent","node":{"__id__":29},"clickEvents":[{"__type__":"cc.ClickEvent","target":{"__id__":24},"_componentId":"e29978G82pFBpxB5U/maz/Y","handler":"loadScene"}],"_normalSprite":{"__uuid__":"20g1ukYUVPvKWKBRznAKo+@f9941"},"_hoverSprite":{"__uuid__":"20g1ukYUVPvKWKBRznAKo+@f9941"},"_pressedSprite":{"__uuid__":"54TknWPwVPqJqeCR+Y/Czo@f9941"},"_disabledSprite":{"__uuid__":"95EkngnxZFbYuFpsqVTaFr@f9941"},"_target":{"__id__":29}},{"__type__":"cc.WidgetComponent","node":{"__id__":29},"_alignFlags":9,"_left":29.999999999999993,"_top":60},{"__type__":"cc.LabelComponent","node":{"__id__":29},"_color":{"__type__":"cc.Color"},"_string":"返回","_actualFontSize":40,"_font":{"__uuid__":"61db6zNg9MjLsrLAkPDs8R"},"_isSystemFontUsed":false}],"_lpos":{"__type__":"cc.Vec3","x":-250,"y":400},"_layer":33554432}],{"__type__":"cc.Material","_effectAsset":{"__uuid__":"1brw/JvvpFnIvdrxpFCgMZ"},"_defines":[{"USE_ALBEDO_MAP":true}],"_states":[{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}}],"_props":[{"mainColor":{"__type__":"cc.Color","g":92,"b":255},"mainTexture":{"__uuid__":"a1ih0MqzRL/7RNLTanAapD@6c48a"}}]}]
